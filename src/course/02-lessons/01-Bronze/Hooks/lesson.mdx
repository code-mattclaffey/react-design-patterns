import { Meta } from '@storybook/blocks';

<Meta title="Lessons/ðŸ¥‰ Bronze/ðŸŽ£ Hooks Pattern/01-Lesson" />

# ðŸŽ£ Hooks Pattern

React Hooks, introduced in React 16.8, revolutionize the traditional presentational and container component pattern by allowing functional components to manage state and side effects directly. This means you no longer need to separate components into presentational (stateless) and container (stateful) types. Hooks like useState and useEffect enable functional components to handle both UI rendering and business logic, simplifying code and improving readability.

Additionally, Hooks enhance reusability and reduce prop drilling. Custom Hooks allow you to extract and share logic across components, promoting a more modular codebase. With features like useContext, managing global state becomes easier, further streamlining development and making your React applications more maintainable and efficient.

## Before Hooks

Before hooks we used to have to make class components which enforced a lot of prop drilling into components and a lot more complicated setup for state management. The Presentational & Container pattern was used a lot more back when we were using class components and that was purely for that separation of concerns.

```jsx
import React, { Component } from 'react';

class PokemonCapture extends Component {
  constructor(props) {
    super(props);
    this.state = {
      capturing: false,
      wildPokemon: null,
      pokeballs: 10,
      capturedPokemon: []
    };
  }

  componentDidMount() {
    this.encounterWildPokemon(this.props.area);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.area !== this.props.area) {
      this.encounterWildPokemon(this.props.area);
    }
  }

  componentWillUnmount() {
    // cleanup capture animations
  }

  encounterWildPokemon(area) {
    // find random pokemon in area
  }

  async attemptCapture(pokemon) {
    this.setState({ capturing: true });
    // capture logic with success rate
    await this.throwPokeball(pokemon);
    this.setState({ capturing: false });
  }
  render() {
    // ... pokemon capture jsx
  }
}
export default PokemonCapture;
```

## With Hooks

With Hooks, functional components can handle both the presentational aspects and the business logic. This means you no longer need to separate your components strictly into presentational and container types.

```jsx
import React, { useState, useEffect } from 'react';

const PokemonCapture = ({ area }) => {
  const [capturing, setCapturing] = useState(false);
  const [wildPokemon, setWildPokemon] = useState(null);
  const [pokeballs, setPokeballs] = useState(10);
  const [capturedPokemon, setCapturedPokemon] = useState([]);

  useEffect(() => {
    encounterWildPokemon(area);
  }, [area]);

  const encounterWildPokemon = (area) => {
    // find random pokemon in area
  };

  const attemptCapture = async (pokemon) => {
    setCapturing(true);
    // capture logic with success rate
    await throwPokeball(pokemon);
    setCapturing(false);
  };

  return (
    // Pokemon capture interface jsx
  );
};
```

## Exercise

In this lesson we are going to refactor the Pokemon capture component into a custom React hook called **usePokemonCapture()** instead of following the render props pattern.

You'll create a hook that manages capture attempts, pokeball inventory, success rates, and wild Pokemon encounters.

Head over to the exercise and let's get started.

## Feedback

Feedback is a gift and it helps me make this course better for you. If you have a spare 5 mins please could you fill out a feedback form for me. Thank you.

[Feedback](https://github.com/code-mattclaffey/react-design-patterns/issues/new)
