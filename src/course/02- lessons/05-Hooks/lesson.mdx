import { Meta } from '@storybook/blocks';

<Meta title="Lessons/05 - Hooks Pattern/01-Lesson" />

# Hooks Pattern

React Hooks, introduced in React 16.8, revolutionize the traditional presentational and container component pattern by allowing functional components to manage state and side effects directly. This means you no longer need to separate components into presentational (stateless) and container (stateful) types. Hooks like useState and useEffect enable functional components to handle both UI rendering and business logic, simplifying code and improving readability.

Additionally, Hooks enhance reusability and reduce prop drilling. Custom Hooks allow you to extract and share logic across components, promoting a more modular codebase. With features like useContext, managing global state becomes easier, further streamlining development and making your React applications more maintainable and efficient.

## Before Hooks

Before hooks we used to have to make class components which enforced a lot of prop drilling into components and a lot more complicated setup for state management. The Presentational & Container pattern was used a lot more back when we were using class components and that was purely for that seperation of concerns.

```jsx
import React, { Component } from 'react';

class Profile extends Component {
  constructor(props) {
    super(props);
    this.state = {
      loading: false,
      user: {}
    };
  }

  componentDidMount() {
    this.updateProfile(this.props.id);
  }

  componentDidUpdate(prevProps) {
    if (prevProps.id !== this.props.id) {
      this.updateProfile(this.props.id);
    }
  }

  componentWillUnmount() {
    // do some unmounting actions
  }

  fetchUser(id) {
    // fetch users logic here
  }

  async updateProfile(id) {
    this.setState({ loading: true });
    // fetch users data
    await this.fetchUser(id);
    this.setState({ loading: false });
  }
  render() {
    // ... some jsx
  }
}
export default Profile;
```

## With Hooks

With Hooks, functional components can handle both the presentational aspects and the business logic. This means you no longer need to separate your components strictly into presentational and container types.

```jsx
import React from 'react';

const Profile = ({ id }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [user, setUser] = useState({});

  useEffect(() => {
    updateProfile(id);
  }, [id]);

  const fetchUser = (id) => {
    // fetch users logic here
  };

  const updateProfile = async (id) => {
    setIsLoading(true);
    // fetch users data
    await fetchUser(id);
    setIsLoading(false);
  };

  return {
    // Some jsx code
  };
};
```

## Exercise

In this lesson we are going to refactor the Field component that we made into a react hook instead of following the render props pattern.

Head over to the exercise and let's get started.

## Feedback

Feedback is a gift and it helps me make this course better for you. If you have a spare 5 mins please could you fill out a feedback form for me. Thank you.

[Feedback](https://forms.gle/FKgHT2Xpfc9xzyxQ8)
